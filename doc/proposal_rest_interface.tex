\documentclass[a4paper]{article}

\usepackage[default,osfigures,scale=0.95]{opensans} %% Alternatively
%% use the option 'defaultsans' instead of 'default' to replace the
%% sans serif font only.
\usepackage[T1]{fontenc}

\usepackage{booktabs}
\usepackage{fancyvrb}
\usepackage{natbib}
\bibliographystyle{chicago}

\title{General REST interface for CSPA services}
\author{Jan van der Laan \and Edwin de Jonge}

\begin{document}

\maketitle

\begin{abstract}
A generic REST interface is proposed which can be used by many of the services
in CSPA. Furthermore, it is possible to develop a generic implementation which
can be used to wrap the REST interface around an existing service making
implemenatation much more simple. A generic interface used by most of the
services would makes it easier to implement systems that use the services.
\end{abstract}

\section{Introduction}

In this report we propose a generic REST (REpresentational State Transfer)
interface, which could be adapted by a large number of services created in the
CSPA project \citep{cspa2013}. Many statistical services are simple data
processing steps. As input a service receives one or more datasets with some
parameters. It will perform some sort of computation, which could take a
substantial amount of time.  When finished, the service returns one or more
result data sets with some logging information.  Since many services, especially
in phase 5 of the GSBPM \citep{gsbpm2013}, follow this
pattern, it is possible to design a generic REST interface for data processing
services.  A homogeneous interface for most CSPA services would make using and
documenting the services much simpler. 

Furthermore, we believe that it is possible to create a generic REST wrapper
implementing this interface that can be used to wrap a command-line CPSA service
with its parameters (CLI). This would reduce the time to implement a CSPA
service considerably.  This also means that institutes can work together on
implementing and perfecting this wrapper, creating a much more robust and tested
interface and that institutes implementing a service do not need to have
extensive knowlegde on implementing REST interfaces. 

RESTful applications use HTTP requests for CRUD (Create, Read, Update and
Delete) operations and maps these on the HTTP verbs POST, GET, PUT and DELETE.
All state is modeled with resources. We consider the following as a resource:

\begin{itemize}
  \item Input data are \emph{data resources} to be retrieved by the service.
  \item Results are \emph{data resources} generated by the service.
  \item Log files are \emph{text resources} generated by the service.
  \item One processing step is modeled as a \emph{job resource} located at the
  service.
\end{itemize}

Therefore, invoking the REST service consists of posting a job resource to the
REST service. This job contains the parameters and references to the data
resources that are needed by the (CLI) service.  The REST service updates the
job resource with information on the status of the job and, when the job has
finished, references to the log files and result data resources. Each job has a
unique id and URL where the current status of the job can be retrieved (using a
GET). 

\section{REST interface}
Since the REST interface revolves around the job resource, we give first a
description of this resource. After that a description of the REST interface is
given. 

\subsection{Job}

The key resource for the service is the job resource. A job resource contains
the following information:
\begin{description}
  \item[id] Job id to be used in querying the job properties.
  \item[url] Unique URL to this job (includes job id).
  \item[name] Human readable name of the calling process.
  \item[version] Version of the service that created this job.
  \item[input] The input is service specific and can consist of:
    \begin{itemize}
      \item Data resources: URL endpoints to input data and its describing meta data, that are to be
      retrieved using GET by the service
      \item Configuration parameters. Simple types (such as string, integer or
      float) can be passed by value. Complex configuration object can be passed
      by reference (URL). 
    \end{itemize}
  \item[result] The results are service specific and will consist of:
    \begin{itemize}
      \item Data resources: URL endpoints to generated output data that are to
      be serviced by the service.
    \end{itemize}
  \item[log] Contains a URL to the log file of the job. 
  \item[status] Can have one of the following values: `created', `scheduled',
  `running', `finished', `error'.
  \item[created] Time at which the job was created (in UTC).
  \item[started] Time at which the job was started (in UTC)
  \item[finished] Time at which the job has finished (in UTC)
  \item[on\_end] A user can optionally provide a callback URL which gets called
  (post of the job URL) when the job has finished. This is a common pattern in asynchronous processing.
\end{description}
Some of this information is only available when relevant. For example, the
\emph{result} of the job resource is only available when the job has finished
(and the job \emph{status} is `finished'). 

The service returns the job in JSON (JavaScript Object Notation) format. An
example of a complete job description as could be returned by a service (we used
the Linear Rule Checking service as an example):
{\small
\begin{Verbatim}
{
  "id" : "1234",
  "url" : "http://example.com/LRC/job/1234",
  "version": "0.0.1",
  "name" : "my_process",
  "status" : "finished",
  "input" : {
    "data" : {
      "type" : "ddi+csv",
      "meta" : "http://previous/service/job/1/result/output/meta",
      "data" : "http://previous/service/job/1/result/output/data",
    },
    "rules": {
      "type" : "text",
      "data" : "http://allthedatayouneed.com/myrules.txt"
    }
  }, 
  "result": {
    "checks" : {
      "type" : "ddi+csv",
      "meta" : "http://example.com/LRC/job/1234/result/checks/meta",
      "data" : "http://example.com/LRC/job/1234/result/checks/data"
    }
  }, 
  "log": {
    "type":"text"
    "url" : "http://example.com/LRC/job/1234/log",
  },
  "created": "2014-01-01T12:00" ,
  "started": "2014-01-01T12:00" ,
  "finished": "2014-01-01T12:05" ,
  "on_end" : "http://callback.com"
}
\end{Verbatim}
}
One thing that can be noted is that the references to the data resources consist
of (two or) three parts: type, data and meta. The exact method of passing data
around in CSPA is currently undecided. Section~\ref{sec:dataresources} further
discusses this topic. For the REST interface the exact method is not important.
The only thing that is important is that data is passed by reference, e.g. by
passing URLs to data resources.

When creating a new job, only a subset of the information above needs to be
passed to the service, namely: \emph{name}, \emph{input} and optionally
\emph{on\_end}. The service expects the job in JSON format, for example:
{\small
\begin{Verbatim}
{
  "name" : "my_process",
  "input" : {
    "data" : {
      "type" : "ddi+csv",
      "meta" : "http://previous/service/job/1/result/output/meta",
      "data" : "http://previous/service/job/1/result/output/data",
    },
    "rules": {
      "type" : "text",
      "data" : "http://allthedatayouneed.com/myrules.txt"
    }
  }, 
  "on_end" : "http://callback.com"
}
\end{Verbatim}
}

The additional information is added to the job description as it becomes
available to the service. 

\subsection{Description of the interface}

Table~\ref{tab:interf} gives an overview of the proposed REST interface.  A
service can be invoked by posting a job description to
\texttt{/<servicename>/job}. This will create the job and schedule it for
execution. On successful creation of the job a URL to the newly created job is
returned. These URLs have the following form:
\texttt{/<servicename>/job/<jobid>}.  Using this URL information on the job can
be requested and the job can be deleted.

\begin{table}
  \caption{REST interface for CSPA services}
  \label{tab:interf}
  \begin{tabular}{l l l p{0.6\textwidth}}
    \toprule
    Resource & HTTP & Respone & Description \\
             & verb & code    &  \\

    \midrule
    \multicolumn{4}{l}{\texttt{/<servicename>/job}} \\
    & POST &  & Creates a job. Uses \emph{input parameters package} \\
    &   & 201 & Job successfully created. Returns URL to created job. Job execution is started. \\
    &   & 412 & Precondition failed. Job is not created.\\
    & GET  &  & Returns a list of all jobs at the service \\

    \multicolumn{4}{l}{\texttt{/<servicename>/help}} \\
    & GET &   & Returns human-readable help describing input and output parameters of the service. \\
    &   & 200  & OK \\

    \multicolumn{4}{l}{\bf\texttt{/<servicename>/example}} \\
    & GET &   & Returns a working test example for the service \\
    &   & 200  & OK \\

    \multicolumn{4}{l}{\bf\texttt{/<servicename>/example/input/<datasetname>}} \\
    & GET &   & Returns a working test example data set for the service \\
    &   & 200  & OK \\
    &   & 404  & NotFound \\

    \multicolumn{4}{l}{\texttt{/<servicename>/job/<jobid>}} \\
    & GET &    & Returns \emph{information response package} regarding specific job \\
    &   & 200  & OK \\
    &   & 404  & NotFound \\
    & DELETE & &  \\
    &   & 200  & OK \\
    &   & 401  & Unauthorized \\

    \multicolumn{4}{l}{\texttt{/<servicename>/job/<jobid>/result/<datasetname>/data}} \\
    & GET &    & Returns the physical data set \\
    &   & 200  & OK \\
    &   & 204  & NoContent. The data set is incomplete and is not returned. \\
    &   & 404  & NotFound \\

    \multicolumn{4}{l}{\texttt{/<servicename>/job/<jobid>/result/<datasetname>/meta}} \\
    & GET &    & Returns the meta data of the data set \\
    &   & 200  & OK \\
    &   & 204  & NoContent. The data set is incomplete and is not returned. \\
    &   & 404  & NotFound \\

    \multicolumn{4}{l}{\texttt{/<servicename>/job/<jobid>/log}} \\
    & GET &    & Returns the log file \\
    &   & 200  & OK. Returns the complete log file \\
    &   & 206  & PartialContent. Returns an incomplete log file. \\
    &   & 404  & NotFound \\
    \bottomrule
  \end{tabular}
\end{table}

Any data generated by the job, such as data sets and logging information, can be
obtained from URLs nested within the job. For example, logging information can
always (all jobs should be required to generate some logging information) be
obtained from \texttt{/<servicename>/job/<jobid>/log}. 

Documentation of the services is very important. Therefore, we suggest that each
service will also provide an interface for documentation. We propose
\texttt{/<servicename>/help} for human readable help and
\texttt{/<servicename>/example} for an example including example data sets. 

Since a job can run for a substantial amount of time the orchestrator needs to
know when the service is finished. There are two possible methods for this. The
simplest is to poll regularly to check if the service has finished. Since the
frequency of this polling can be quite low, this will probably not introduce any
significant load on the server. Furthermore, the service could use the
\texttt{Expires} header to indicate the time after which the job is expected to
have finished. A second possibility is to pass a callback to the service using
the \texttt{on\_end} parameter of the job. The URL in the \texttt{on\_end}
parameter will receive a POST with the URL to the job when the job has finished. 

\subsection{Other points, open ends and possible extensions}

\subsubsection{Data resources}
\label{sec:dataresources}
In the current description of the REST interface, data resources consist of
three parts: a type, a URL to the meta data and a URL to the data. In the
examples above DDI is used for the meta data format and CSV as the data format.
The current specification of CSPA does not prescribe a single data format.
However, if we want to be able to connect services with a little effort as
possible (which is one of the key goals of CSPA) some sort of agreement has to
be reached on the data format used for exchange between the services. 

The exact data and meta data format used by the CSPA services, is not important
for the exact interface used, except for the following two points:
\begin{itemize}
  \item It is probably best to transfer the meta data and the data separately.
  First, (depending on the meta data format used) parsing the meta data is
  difficult for large data sets when the data and meta data are in the same
  file. Second, services will often be called with different data sets while the
  meta data will remain the same, e.g. running the same service each month for
  the new monthly figures. 
  \item Data and meta data should be passed by reference as it is one of the key
  concepts of REST that not the resource itself but the URL to the resource is
  passed around. Furthermore, for large data sets this might also be more
  efficient as the service might not need all of the data and can also be passed
  a query in the URL.
\end{itemize}

\subsubsection{Data resource ownership}
In the current proposal the services will also serve the data sets generated by
the service. This raises questions on the responsibilities of the statistical
service for the management of the data sets, e.g. do the data sets remain at the
service indefinitely or are they automatically removed after a certain period? 

Another solution is that besides the statistical services there is also a data
service which is responsible for the data resources. However, even then the
question remains who is responsible for transferring the data to the data
service? The statistical service of the orchestrator? 

\subsubsection{Chaining services}
In the current design it is relatively easy to chain the services. A service B
which uses the output from service A can be passed a URL to the output of
service A. All the orchestrator has to do is create the jobs on the different
services passing in the correct URLs. 

\subsubsection{Versioning}
Clients can ask for a specific version of the service in the HEAD of the POST
message by using the \texttt{Accept-Version=<version number>} header. When
omitted the service will use the latest version.


\subsubsection{Requesting a specific output format}
\label{sec:outputformat}
Using \texttt{Accept=<mimetype>} in the HEAD of a GET request clients can ask for
specific representations of a resource. In case of the CSPA service this could
mean the asking for \texttt{application/json} on \texttt{/<servicename>/job}
will return a list of jobs in JSON format, while asking for \texttt{text/html}
will return a (possibly interactive) web page showing the status of all jobs.


\subsubsection{Machine readable description of input and output parameters}
The interface contains a help page which gives a human readable description of
input and output parameters. It might possible also be of interest to also
generate a machine readable description. This could for example be used to
automatically generate controls (e.g. input fields) on a orchestrator. One way
to implement this would be to allow a client request JSON data from the help
page (see~\ref{sec:outputformat}). 


\subsubsection{Authentication}
Http allows for authentication. This allows for restrictions on creating jobs,
deleting jobs, listing jobs, etc and can also be used the restrict access to
data. Since it is the service which needs to access the data, the service needs
to be authorized to access certain data resources. The best method for handling
this needs to be investigated. 


\subsection{Generic implementation}
The interface as discussed above can be used for a large number of services. Any
service that accepts a number of input data sources with some parameters,
performs some sort of computation and then returns one or more output data-sets
can probably be served by the interface presented above. Furthermore, many
statistical programs can be run from the command line by passing in some
arguments and data sets. For example, SPSS, R and SAS code can be run in this
way. All the REST service has to do is to translate the input parameters of the
job into the command line arguments, start the code and subsequently serve the
output files generated.  It is relatively easy to build a generic service that
is able to serve any command line code that can be run in this way. Only a small
amount of configuration is needed to translate the input arguments of the
submitted job into the command line arguments. 

The advantage of such a generic implementation is that all services using this
implementation will have the same structured interface, except for its input and output paramters. Also, implementation is
much easier. Not everybody implementing a service for CSPA will have to be able
to implement a REST service. When the implementation is used by multiple
services, this will also mean that the implementation is tested much more and
will therefore be much more stable. 




\section{Conclusion}

In the previous paragraphs a REST interface is proposed which can be used by
most statistical services. We feel that in order to let CSPA succeed it is
necessary to have uniform interfaces and uniform data
formats. Therefore, we propose that the REST interface proposed above is used as
a starting point for a generic REST interface that is to be used by most of the
CSPA services. 


\bibliography{references.bib}

\end{document}
